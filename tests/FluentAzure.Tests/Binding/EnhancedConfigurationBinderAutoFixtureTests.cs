using System.ComponentModel.DataAnnotations;
using AutoFixture;
using AutoFixture.Xunit2;
using FluentAssertions;
using FluentAzure.Binding;
using FluentAzure.Core;
using FluentAzure.Tests.Binding;
using Xunit;
using static FluentAzure.Tests.Binding.EnhancedConfigurationBinderParameterTests;

namespace FluentAzure.Tests.Binding;

/// <summary>
/// AutoFixture-based parameterized tests for the enhanced configuration binding system.
/// These tests use AutoFixture to generate test data automatically.
/// </summary>
public class EnhancedConfigurationBinderAutoFixtureTests
{
    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedSimpleTypes_ShouldSucceed(string name, int value, bool flag, double number)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["Name"] = name,
            ["Value"] = value.ToString(),
            ["Flag"] = flag.ToString(),
            ["Number"] = number.ToString("F2")
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<AutoFixtureTestClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().NotBeNull();
        result.Value!.Name.Should().Be(name);
        result.Value.Value.Should().Be(value);
        result.Value.Flag.Should().Be(flag);
        result.Value.Number.Should().BeApproximately(number, 0.01);
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedNullableTypes_ShouldHandleNulls(string requiredString, int requiredInt)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["RequiredString"] = requiredString,
            ["RequiredInt"] = requiredInt.ToString(),
            // Leave nullable fields empty to test null handling
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<AutoFixtureNullableClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().NotBeNull();
        result.Value!.RequiredString.Should().Be(requiredString);
        result.Value.RequiredInt.Should().Be(requiredInt);
        result.Value.NullableString.Should().BeNull();
        result.Value.NullableInt.Should().BeNull();
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedRecord_ShouldSucceed(string name, string version, string environment, int maxConnections, bool enableFeature)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["Name"] = name,
            ["Version"] = version,
            ["Environment"] = environment,
            ["MaxConnections"] = maxConnections.ToString(),
            ["EnableFeature"] = enableFeature.ToString()
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<TestRecord>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().NotBeNull();
        result.Value!.Name.Should().Be(name);
        result.Value.Version.Should().Be(version);
        result.Value.Environment.Should().Be(environment);
        result.Value.MaxConnections.Should().Be(maxConnections);
        result.Value.EnableFeature.Should().Be(enableFeature);
    }

    /// <summary>
    /// Verifies that the binder can correctly bind a collection of items using auto-generated data.
    /// </summary>
    /// <param name="item1Name">The name of the first item.</param>
    /// <param name="item1Value">The value of the first item.</param>
    /// <param name="item2Name">The name of the second item.</param>
    /// <param name="item2Value">The value of the second item.</param>
    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedCollections_ShouldSucceed(string item1Name, int item1Value, string item2Name, int item2Value)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["Items:0:Name"] = item1Name,
            ["Items:0:Value"] = item1Value.ToString(),
            ["Items:1:Name"] = item2Name,
            ["Items:1:Value"] = item2Value.ToString()
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<AutoFixtureCollectionClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().NotBeNull();
        result.Value!.Items.Should().HaveCount(2);
        result.Value.Items[0].Name.Should().Be(item1Name);
        result.Value.Items[0].Value.Should().Be(item1Value);
        result.Value.Items[1].Name.Should().Be(item2Name);
        result.Value.Items[1].Value.Should().Be(item2Value);
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedNestedObjects_ShouldSucceed(string nestedName, int nestedValue, string deepName, int deepValue)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["Nested:Name"] = nestedName,
            ["Nested:Value"] = nestedValue.ToString(),
            ["Nested:Deep:Name"] = deepName,
            ["Nested:Deep:Value"] = deepValue.ToString()
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<AutoFixtureNestedClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().NotBeNull();
        result.Value!.Nested.Should().NotBeNull();
        result.Value.Nested.Name.Should().Be(nestedName);
        result.Value.Nested.Value.Should().Be(nestedValue);
        result.Value.Nested.Deep.Should().NotBeNull();
        result.Value.Nested.Deep.Name.Should().Be(deepName);
        result.Value.Nested.Deep.Value.Should().Be(deepValue);
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedEnums_ShouldSucceed(TestEnum enumValue, UserStatus statusValue)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["EnumProperty"] = enumValue.ToString(),
            ["StatusProperty"] = statusValue.ToString()
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<AutoFixtureEnumClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().NotBeNull();
        result.Value!.EnumProperty.Should().Be(enumValue);
        result.Value.StatusProperty.Should().Be(statusValue);
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedValidationData_ShouldRespectValidationRules(string validEmail, int validAge, string requiredField)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["Email"] = validEmail,
            ["Age"] = validAge.ToString(),
            ["RequiredField"] = requiredField,
            ["RangeField"] = "50" // Valid range value
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<AutoFixtureValidatedClass>(config);

        // Assert
        // Should succeed if validation passes, or fail with validation errors
        if (result.IsSuccess)
        {
            result.Value.Should().NotBeNull();
            result.Value!.Email.Should().Be(validEmail);
            result.Value.Age.Should().Be(validAge);
            result.Value.RequiredField.Should().Be(requiredField);
        }
        else
        {
            result.Errors.Should().AllSatisfy(error =>
                error.Should().ContainAny("validation", "Required", "Email", "Age", "Range"));
        }
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedCaseVariations_ShouldBeCaseInsensitive(string name, int value, bool flag)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["name"] = name, // lowercase
            ["VALUE"] = value.ToString(), // uppercase
            ["Flag"] = flag.ToString() // mixed case
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<AutoFixtureTestClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().NotBeNull();
        result.Value!.Name.Should().Be(name);
        result.Value.Value.Should().Be(value);
        result.Value.Flag.Should().Be(flag);
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedSeparatorVariations_ShouldHandleBothSeparators(string name, int value)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["Nested:Name"] = name, // colon separator
            ["Nested__Value"] = value.ToString() // underscore separator
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<AutoFixtureNestedClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().NotBeNull();
        result.Value!.Nested.Should().NotBeNull();
        result.Value.Nested.Name.Should().Be(name);
        result.Value.Nested.Value.Should().Be(value);
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedSpecialCharacters_ShouldEscapeProperly(string specialString, int value)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["SpecialString"] = specialString,
            ["Value"] = value.ToString(),
            ["Key:With:Colons"] = "test",
            ["Key__With__Underscores"] = "test"
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<AutoFixtureSpecialCharsClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().NotBeNull();
        result.Value!.SpecialString.Should().Be(specialString);
        result.Value.Value.Should().Be(value);
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedLargeValues_ShouldHandleSizeLimits(string largeString, int value)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["LargeString"] = largeString,
            ["Value"] = value.ToString()
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<AutoFixtureLargeValueClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().NotBeNull();
        result.Value!.LargeString.Should().Be(largeString);
        result.Value.Value.Should().Be(value);
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedEmptyValues_ShouldHandleGracefully(string requiredString, int requiredInt)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["RequiredString"] = requiredString,
            ["RequiredInt"] = requiredInt.ToString(),
            ["NullableString"] = "", // empty string
            ["NullableInt"] = "", // empty string
            ["WhitespaceString"] = "   ", // whitespace only
            ["NullString"] = "null" // "null" string
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<AutoFixtureEmptyValueClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().NotBeNull();
        result.Value!.RequiredString.Should().Be(requiredString);
        result.Value.RequiredInt.Should().Be(requiredInt);
        result.Value.NullableString.Should().BeNull(); // Should be null due to empty string
        result.Value.NullableInt.Should().BeNull(); // Should be null due to empty string
    }

    // Test classes for AutoFixture tests
    public class AutoFixtureTestClass
    {
        public string Name { get; set; } = string.Empty;
        public int Value { get; set; }
        public bool Flag { get; set; }
        public double Number { get; set; }
    }

    public class AutoFixtureNullableClass
    {
        public string RequiredString { get; set; } = string.Empty;
        public int RequiredInt { get; set; }
        public string? NullableString { get; set; }
        public int? NullableInt { get; set; }
    }

    public class AutoFixtureCollectionClass
    {
        public List<AutoFixtureCollectionItem> Items { get; set; } = new();
    }

    public class AutoFixtureCollectionItem
    {
        public string Name { get; set; } = string.Empty;
        public int Value { get; set; }
    }

    public class AutoFixtureNestedClass
    {
        public AutoFixtureNestedProperty Nested { get; set; } = new();
    }

    public class AutoFixtureNestedProperty
    {
        public string Name { get; set; } = string.Empty;
        public int Value { get; set; }
        public AutoFixtureDeepProperty Deep { get; set; } = new();
    }

    public class AutoFixtureDeepProperty
    {
        public string Name { get; set; } = string.Empty;
        public int Value { get; set; }
    }

    public class AutoFixtureEnumClass
    {
        public TestEnum EnumProperty { get; set; }
        public UserStatus StatusProperty { get; set; }
    }

    public class AutoFixtureValidatedClass
    {
        [Required]
        [EmailAddress]
        public string Email { get; set; } = string.Empty;

        [Required]
        [Range(1, 120)]
        public int Age { get; set; }

        [Required]
        public string RequiredField { get; set; } = string.Empty;

        [Range(1, 100)]
        public int RangeField { get; set; }
    }

    public class AutoFixtureSpecialCharsClass
    {
        public string SpecialString { get; set; } = string.Empty;
        public int Value { get; set; }
    }

    public class AutoFixtureLargeValueClass
    {
        public string LargeString { get; set; } = string.Empty;
        public int Value { get; set; }
    }

    public class AutoFixtureEmptyValueClass
    {
        public string RequiredString { get; set; } = string.Empty;
        public int RequiredInt { get; set; }
        public string? NullableString { get; set; }
        public int? NullableInt { get; set; }
        public string? WhitespaceString { get; set; }
        public string? NullString { get; set; }
    }
}

public static class TypeExtensions
{
    public static bool IsCollectionType(this Type type)
    {
        return type.IsArray
            || (
                type.IsGenericType
                && typeof(IEnumerable<>).IsAssignableFrom(type.GetGenericTypeDefinition())
            );
    }
}
