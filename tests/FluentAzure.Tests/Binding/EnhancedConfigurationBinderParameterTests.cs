using System.ComponentModel.DataAnnotations;
using System.Text.Json;
using AutoFixture;
using AutoFixture.Xunit2;
using FluentAssertions;
using FluentAzure.Binding;
using FluentAzure.Core;
using FluentAzure.Tests.Binding;
using Xunit;

namespace FluentAzure.Tests.Binding;

/// <summary>
/// Parameter-based tests for the enhanced configuration binding system using AutoFixture.
/// These tests generate random data to ensure the binder handles edge cases robustly.
/// </summary>
public class EnhancedConfigurationBinderParameterTests
{
    private readonly Fixture _fixture;

    public EnhancedConfigurationBinderParameterTests()
    {
        _fixture = new Fixture();
        _fixture
            .Behaviors.OfType<ThrowingRecursionBehavior>()
            .ToList()
            .ForEach(b => _fixture.Behaviors.Remove(b));
        _fixture.Behaviors.Add(new OmitOnRecursionBehavior());
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedSimpleTypes_ShouldSucceed(string name, int value, bool flag, double number)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["StringProperty"] = name,
            ["IntProperty"] = value.ToString(),
            ["BoolProperty"] = flag.ToString().ToLower(),
            ["DoubleProperty"] = number.ToString("F2"),
            ["DateTimeProperty"] = DateTime.UtcNow.ToString("O"),
            ["GuidProperty"] = Guid.NewGuid().ToString(),
            ["UriProperty"] = "https://example.com",
            ["DecimalProperty"] = number.ToString("F2"),
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<SimpleTestClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        if (result.IsSuccess)
        {
            result.Value.StringProperty.Should().Be(name);
            result.Value.IntProperty.Should().Be(value);
            result.Value.BoolProperty.Should().Be(flag);
        }
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedNullableTypes_ShouldHandleNullsCorrectly(string requiredString, int requiredInt)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["RequiredString"] = requiredString,
            ["RequiredInt"] = requiredInt.ToString(),
            // Leave nullable fields empty to test null handling
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<NullableTestClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        if (result.IsSuccess)
        {
            result.Value.RequiredString.Should().Be(requiredString);
            result.Value.RequiredInt.Should().Be(requiredInt);
            result.Value.NullableString.Should().BeNull();
            result.Value.NullableInt.Should().BeNull();
        }
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedRecordTypes_ShouldSucceed(string name, string version, string environment, int maxConnections, bool enableFeature)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["Name"] = name,
            ["Version"] = version,
            ["Environment"] = environment,
            ["MaxConnections"] = maxConnections.ToString(),
            ["EnableFeature"] = enableFeature.ToString().ToLower(),
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<TestRecord>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        if (result.IsSuccess)
        {
            result.Value.Name.Should().Be(name);
            result.Value.Version.Should().Be(version);
            result.Value.Environment.Should().Be(environment);
            result.Value.MaxConnections.Should().Be(maxConnections);
            result.Value.EnableFeature.Should().Be(enableFeature);
        }
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedCollections_ShouldHandleVariousSizes(int itemCount)
    {
        // Arrange
        var config = new Dictionary<string, string>();
        var expectedCount = Math.Min(itemCount, 10);
        for (int i = 0; i < expectedCount; i++) // Limit to reasonable size
        {
            var itemName = _fixture.Create<string>();
            var itemValue = _fixture.Create<int>();
            config[$"Items__{i}__Name"] = itemName;
            config[$"Items__{i}__Value"] = itemValue.ToString();
        }

        // Act
        var result = EnhancedConfigurationBinder.Bind<CollectionTestClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        if (result.IsSuccess)
        {
            result.Value.Items.Should().HaveCount(expectedCount);
        }
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedNestedObjects_ShouldHandleDepth(string nestedName, int nestedValue)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["NestedProperty__Name"] = nestedName,
            ["NestedProperty__Value"] = nestedValue.ToString(),
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<NestedTestClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        if (result.IsSuccess)
        {
            result.Value.NestedProperty.Name.Should().Be(nestedName);
            result.Value.NestedProperty.Value.Should().Be(nestedValue);
        }
    }

    [Fact]
    public void Bind_WithAutoGeneratedEnumValues_ShouldHandleAllEnumCases()
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["EnumProperty"] = TestEnum.Value1.ToString(),
            ["StatusProperty"] = UserStatus.Active.ToString(),
            ["CaseInsensitiveEnum"] = TestEnum.Value2.ToString().ToLower(),
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<EnumTestClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        if (result.IsSuccess)
        {
            result.Value.EnumProperty.Should().Be(TestEnum.Value1);
            result.Value.StatusProperty.Should().Be(UserStatus.Active);
            result.Value.CaseInsensitiveEnum.Should().Be(TestEnum.Value2);
        }
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedCaseVariations_ShouldBeCaseInsensitive(string name, int value)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["stringproperty"] = name, // lowercase
            ["INTPROPERTY"] = value.ToString(), // uppercase
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<SimpleTestClass>(config, new BindingOptions { CaseSensitive = false });

        // Assert
        result.IsSuccess.Should().BeTrue();
        if (result.IsSuccess)
        {
            result.Value.StringProperty.Should().Be(name);
            result.Value.IntProperty.Should().Be(value);
        }
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedSeparators_ShouldHandleBothColonAndUnderscore(string name, int value)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["Nested:Property:Name"] = name, // colon separator
            ["Nested__Property__Value"] = value.ToString(), // underscore separator
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<NestedTestClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        if (result.IsSuccess)
        {
            result.Value.NestedProperty.Name.Should().Be(name);
            result.Value.NestedProperty.Value.Should().Be(value);
        }
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedValidationRules_ShouldRespectValidation(string email, int age)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["Email"] = email,
            ["Age"] = age.ToString(),
            ["RequiredField"] = _fixture.Create<string>(),
            ["RangeField"] = _fixture.Create<int>().ToString(),
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<ValidatedTestClass>(config);

        // Assert
        // Should succeed if validation passes, or fail with validation errors
        if (result.IsSuccess)
        {
            result.Value.Email.Should().Be(email);
            result.Value.Age.Should().Be(age);
        }
        else
        {
            result.Errors.Should().Contain(e => e.Contains("validation") || e.Contains("Required"));
        }
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedJsonData_ShouldDeserializeCorrectly(string name, string version)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["Name"] = name,
            ["Version"] = version,
            ["Database:Host"] = "localhost",
            ["Database:Port"] = "5432",
            ["Features:Enabled"] = "true",
        };

        // Act
        var result = EnhancedConfigurationBinder.BindJson<SimpleTestClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        if (result.IsSuccess)
        {
            result.Value.StringProperty.Should().Be(name);
        }
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedEmptyValues_ShouldHandleGracefully(string requiredString, int requiredInt)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["RequiredString"] = requiredString,
            ["RequiredInt"] = requiredInt.ToString(),
            ["NullableString"] = "", // empty string
            ["NullableInt"] = "", // empty string
            ["WhitespaceString"] = "   ", // whitespace
            ["NullLikeString"] = "null", // null-like
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<NullableTestClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        if (result.IsSuccess)
        {
            result.Value.RequiredString.Should().Be(requiredString);
            result.Value.RequiredInt.Should().Be(requiredInt);
            result.Value.NullableString.Should().BeNullOrEmpty();
            result.Value.NullableInt.Should().BeNull();
        }
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedSpecialCharacters_ShouldEscapeProperly(string specialString, int value)
    {
        // Arrange
        var config = new Dictionary<string, string>
        {
            ["StringProperty"] = specialString,
            ["IntProperty"] = value.ToString(),
            ["SpecialKey:With:Colons"] = _fixture.Create<string>(),
            ["SpecialKey__With__Underscores"] = _fixture.Create<string>(),
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<SimpleTestClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        if (result.IsSuccess)
        {
            result.Value.StringProperty.Should().Be(specialString);
            result.Value.IntProperty.Should().Be(value);
        }
    }

    [Theory]
    [AutoData]
    public void Bind_WithAutoGeneratedLargeValues_ShouldHandleSizeLimits(int size)
    {
        // Arrange
        var largeString = new string('x', Math.Min(size, 1000)); // Limit to reasonable size
        var config = new Dictionary<string, string>
        {
            ["StringProperty"] = largeString,
            ["IntProperty"] = _fixture.Create<int>().ToString(),
            ["BoolProperty"] = _fixture.Create<bool>().ToString().ToLower(),
        };

        // Act
        var result = EnhancedConfigurationBinder.Bind<SimpleTestClass>(config);

        // Assert
        result.IsSuccess.Should().BeTrue();
        if (result.IsSuccess)
        {
            result.Value.StringProperty.Should().Be(largeString);
        }
    }

    // Helper methods to generate random test data
    private Dictionary<string, string> GenerateRandomSimpleConfiguration()
    {
        var random = new Random();
        return new Dictionary<string, string>
        {
            ["StringProperty"] = _fixture.Create<string>(),
            ["IntProperty"] = random.Next(-1000, 1000).ToString(),
            ["BoolProperty"] = random.Next(2) == 1 ? "true" : "false",
            ["DoubleProperty"] = (random.NextDouble() * 1000 - 500).ToString("F2"),
            ["DateTimeProperty"] = _fixture.Create<DateTime>().ToString("O"),
            ["GuidProperty"] = _fixture.Create<Guid>().ToString(),
            ["UriProperty"] = $"https://example.com/{_fixture.Create<string>()}",
            ["DecimalProperty"] = (random.NextDouble() * 1000 - 500).ToString("F2"),
        };
    }

    private Dictionary<string, string> GenerateRandomNullableConfiguration()
    {
        var random = new Random();
        var config = new Dictionary<string, string>();

        // Sometimes add values, sometimes leave them empty for null testing
        if (random.Next(2) == 1)
            config["NullableString"] = _fixture.Create<string>();
        if (random.Next(2) == 1)
            config["NullableInt"] = random.Next(-1000, 1000).ToString();
        if (random.Next(2) == 1)
            config["NullableBool"] = random.Next(2) == 1 ? "true" : "false";
        if (random.Next(2) == 1)
            config["NullableDouble"] = (random.NextDouble() * 1000 - 500).ToString("F2");

        // Required fields
        config["RequiredString"] = _fixture.Create<string>();
        config["RequiredInt"] = random.Next(-1000, 1000).ToString();

        return config;
    }

    private Dictionary<string, string> GenerateRandomRecordConfiguration()
    {
        var random = new Random();
        return new Dictionary<string, string>
        {
            ["Name"] = _fixture.Create<string>(),
            ["Version"] = $"{random.Next(1, 100)}.{random.Next(0, 100)}.{random.Next(0, 100)}",
            ["Environment"] = _fixture.Create<string>(),
            ["MaxConnections"] = random.Next(1, 10000).ToString(),
            ["EnableFeature"] = random.Next(2) == 1 ? "true" : "false",
        };
    }

    private Dictionary<string, string> GenerateRandomCollectionConfiguration(int size)
    {
        var config = new Dictionary<string, string>();
        var random = new Random();

        for (int i = 0; i < size; i++)
        {
            config[$"Items__{i}__Name"] = _fixture.Create<string>();
            config[$"Items__{i}__Value"] = random.Next(-1000, 1000).ToString();
        }

        return config;
    }

    private Dictionary<string, string> GenerateRandomNestedConfiguration(int depth)
    {
        var config = new Dictionary<string, string>();
        var random = new Random();

        var currentPath = "";
        for (int i = 0; i < depth; i++)
        {
            var separator = random.Next(2) == 1 ? ":" : "__";
            currentPath += (currentPath.Length > 0 ? separator : "") + $"Level{i}";

            config[$"{currentPath}__Name"] = _fixture.Create<string>();
            config[$"{currentPath}__Value"] = random.Next(-1000, 1000).ToString();
        }

        return config;
    }

    private Dictionary<string, string> GenerateRandomEnumConfiguration()
    {
        var random = new Random();
        var enumValues = Enum.GetValues<TestEnum>();
        var statusValues = Enum.GetValues<UserStatus>();

        return new Dictionary<string, string>
        {
            ["EnumProperty"] = enumValues[random.Next(enumValues.Length)].ToString(),
            ["StatusProperty"] = statusValues[random.Next(statusValues.Length)].ToString(),
            ["CaseInsensitiveEnum"] = enumValues[random.Next(enumValues.Length)]
                .ToString()
                .ToLower(),
        };
    }

    private Dictionary<string, string> GenerateRandomCaseVariationConfiguration()
    {
        var random = new Random();
        var baseConfig = GenerateRandomSimpleConfiguration();
        var config = new Dictionary<string, string>();

        foreach (var kvp in baseConfig)
        {
            var key = kvp.Key;
            var value = kvp.Value;

            // Randomly apply case variations
            switch (random.Next(4))
            {
                case 0:
                    key = key.ToLower();
                    break;
                case 1:
                    key = key.ToUpper();
                    break;
                case 2:
                    key = char.ToLower(key[0]) + key.Substring(1);
                    break;
                case 3:
                    key = char.ToUpper(key[0]) + key.Substring(1).ToLower();
                    break;
            }

            config[key] = value;
        }

        return config;
    }

    private Dictionary<string, string> GenerateRandomSeparatorConfiguration()
    {
        var random = new Random();
        var config = new Dictionary<string, string>();

        // Mix both separators randomly
        var useColon = random.Next(2) == 1;
        var separator = useColon ? ":" : "__";

        config[$"Nested{separator}Property{separator}Name"] = _fixture.Create<string>();
        config[$"Nested{separator}Property{separator}Value"] = random.Next(-1000, 1000).ToString();

        return config;
    }

    private Dictionary<string, string> GenerateRandomValidationConfiguration()
    {
        var random = new Random();
        return new Dictionary<string, string>
        {
            ["Email"] = random.Next(2) == 1 ? "valid@email.com" : "invalid-email",
            ["Age"] = random.Next(-10, 200).ToString(), // Some invalid ages
            ["RequiredField"] = random.Next(2) == 1 ? _fixture.Create<string>() : "",
            ["RangeField"] = random.Next(-100, 1000).ToString(), // Some out of range
        };
    }

    private Dictionary<string, string> GenerateRandomJsonConfiguration()
    {
        var random = new Random();
        return new Dictionary<string, string>
        {
            ["Name"] = _fixture.Create<string>(),
            ["Version"] = $"{random.Next(1, 100)}.{random.Next(0, 100)}",
            ["Database:Host"] = "localhost",
            ["Database:Port"] = random.Next(1024, 65535).ToString(),
            ["Features:Enabled"] = random.Next(2) == 1 ? "true" : "false",
        };
    }

    private Dictionary<string, string> GenerateRandomEmptyValueConfiguration()
    {
        var random = new Random();
        var config = new Dictionary<string, string>();

        // Add some empty values
        config["NullableString"] = "";
        config["NullableInt"] = "";
        config["NullableBool"] = "";

        // Add some whitespace-only values
        config["WhitespaceString"] = "   ";
        config["WhitespaceInt"] = "   ";

        // Add some null-like values
        config["NullLikeString"] = "null";
        config["NullLikeInt"] = "null";

        // Required fields
        config["RequiredString"] = _fixture.Create<string>();
        config["RequiredInt"] = random.Next(-1000, 1000).ToString();

        return config;
    }

    private Dictionary<string, string> GenerateRandomSpecialCharacterConfiguration()
    {
        var random = new Random();
        var specialChars = new[]
        {
            "\\",
            "\"",
            "'",
            "&",
            "<",
            ">",
            ":",
            ";",
            "=",
            "?",
            "@",
            "[",
            "]",
            "{",
            "}",
            "|",
            "~",
            "`",
            "!",
            "#",
            "$",
            "%",
            "^",
            "*",
            "(",
            ")",
            "+",
            ",",
            ".",
            "/",
        };

        return new Dictionary<string, string>
        {
            ["StringProperty"] = string.Join(
                "",
                Enumerable.Range(0, 10).Select(_ => specialChars[random.Next(specialChars.Length)])
            ),
            ["IntProperty"] = random.Next(-1000, 1000).ToString(),
            ["BoolProperty"] = random.Next(2) == 1 ? "true" : "false",
            ["SpecialKey:With:Colons"] = _fixture.Create<string>(),
            ["SpecialKey__With__Underscores"] = _fixture.Create<string>(),
        };
    }

    private Dictionary<string, string> GenerateRandomLargeValueConfiguration(int size)
    {
        var random = new Random();
        var largeString = new string('x', size);

        return new Dictionary<string, string>
        {
            ["StringProperty"] = largeString,
            ["IntProperty"] = random.Next(-1000, 1000).ToString(),
            ["BoolProperty"] = random.Next(2) == 1 ? "true" : "false",
        };
    }

    // Test classes for parameter testing
    public class SimpleTestClass
    {
        public string StringProperty { get; set; } = string.Empty;
        public int IntProperty { get; set; }
        public bool BoolProperty { get; set; }
        public double DoubleProperty { get; set; }
        public DateTime DateTimeProperty { get; set; }
        public Guid GuidProperty { get; set; }
        public Uri UriProperty { get; set; } = new Uri("https://example.com");
        public decimal DecimalProperty { get; set; }
    }

    public class NullableTestClass
    {
        public string RequiredString { get; set; } = string.Empty;
        public int RequiredInt { get; set; }
        public string? NullableString { get; set; }
        public int? NullableInt { get; set; }
        public bool? NullableBool { get; set; }
        public double? NullableDouble { get; set; }
    }

    public class CollectionTestClass
    {
        public List<CollectionItem> Items { get; set; } = new();
    }

    public class CollectionItem
    {
        public string Name { get; set; } = string.Empty;
        public int Value { get; set; }
    }

    public class NestedTestClass
    {
        public NestedProperty NestedProperty { get; set; } = new();
    }

    public class NestedProperty
    {
        public string Name { get; set; } = string.Empty;
        public int Value { get; set; }
    }

    public class EnumTestClass
    {
        public TestEnum EnumProperty { get; set; }
        public UserStatus StatusProperty { get; set; }
        public TestEnum CaseInsensitiveEnum { get; set; }
    }

    public class ValidatedTestClass
    {
        [Required]
        [EmailAddress]
        public string Email { get; set; } = string.Empty;

        [Required]
        [Range(1, 120)]
        public int Age { get; set; }

        [Required]
        public string RequiredField { get; set; } = string.Empty;

        [Range(1, 100)]
        public int RangeField { get; set; }
    }
}
